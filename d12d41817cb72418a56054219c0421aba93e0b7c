{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dd5e6360_68a46ade",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T18:01:43Z",
      "side": 1,
      "message": "Although I am looking fairly closely at the instructions, reviews for sve will be pretty easy because they only run on a few cpus, so there is unlikely to be a regression... the code just needs to be faster than neon.\n\nI think we can mix and match neon and sve, so initially we should assume sve has 128 bit vectors and the functions that benefit use interesting new instructions.  Which you did here: umulh and interleaving narrow.\n\nThis function I444ToARGB, may be the single most important function in libyuv.\nI420 and NV12 may get used more but when filtering is on, they upsample to I444 first.  And the code is otherwise the same.\nSo if we can think of other improvements, it would be good to do more on I444ToARGB.  i8mm, dotproduct or ssve?",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30e6d843_15f40566",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note that this shift by 6 to convert from 12.6 is a /64 and wanted rounding\n(v+32)/64  but the rounding was added to the bias.  The problem is, bias rounding value only works when the output is expected to be 8 bit.\nIf we support 10 bit, this shift becomes 4, but the rounding should have been adjusted.\nOne solution is change the shifts to rounding shifts, and remove the rounding value from bias.  We did that on risc-v with a hack.\nthe constants are loaded and then 32 is subtracted from the bias.  then the shift is changed to rounding.\nThe downside is intel doesnt have a rounding shift, so it would hurt performance there.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "757f02d1_e29a8e30",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note sorry about the clang-formatting.  I think the issue is \u0027volatile\u0027 confuses it, so I\u0027m working on a CL to remove all \u0027volatile\u0027 from existing functions.  \ndeclarations have to be accurate for registers clobbered etc.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6cc609df_6a9310a0",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "Is it necessary to have this loop that does sub/b.gt in addition to whilelt?  Could the whilelt loop handle both?",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "985f1a75_3ee194c5",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "I have some misgivings about handling remainders in the low levels, as it doubles the size and increases complexity of assembly, and hurts performance in the common case.  libyuv processes camera frames that are virtually guaranteed to be a multiple of 16 pixels wide.  So this code adds branches and cache misses.\nBut avx512/avx10 have masking, which is similar, and riscv does the remainder with the main loop, so this seems to be the way things are going.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}